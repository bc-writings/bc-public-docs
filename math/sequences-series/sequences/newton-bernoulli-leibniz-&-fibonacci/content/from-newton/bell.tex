Démontrons que
$B_{n+1} = \combisum{B_k}$, 
où
$(B_n)_{n\in\NN}$ désigne la suite des nombres de Bell.
Indépendamment de la technique spécifique à la section \ref{bino-implies},
nous savons que ceci équivaut à démontrer que
$\tabell[n+1][n+1] = \combisum{\tabell[k+1][1]}$,
où
$\tabell[n][n] = \tabell[n+1][1] = B_n$ sur $\NN$,
ainsi que
$\tabell[1][1] = 1$,
et
$\tabell[n+1][p+1] = \tabell[n+1][p] + \tabell$ sur $\NN^2$
(voir page \pageref{tree-bell}).
Inspiré par la suite de Fibonacci, nous introduisons les ingrédients suivants.
%
%\newpage
\begin{itemize}
	\item $\ell(\NN^2 , \RR)$ désigne l'ensemble des suites réelles doublement indexées sur $\NN^2$.%
	\footnote{
		Ici aussi, si besoin, $\RR$ peut être remplacé par un anneau commutatif de son choix.
	}

	\item $\setalge{A} = \Endo \big( \ell(\NN^2 , \RR) \big)$ est l'ensemble des endomorphismes linéaires de $\ell(\NN^2 , \RR)$ muni de l'addition $+$ point par point, et de la composition $\circ$ comme produit.

	\item Pour $(a,b) \in \NN^2$, $\mu_a^b \in \setalge{A}$ désigne un opérateur partiel de décalage qui à la suite $(w_p^m)_{(p,m) \in \NN^2}$ associe la suite $(w_{p+a}^{m+b})_{(p,m) \in \NN^2}$.
\end{itemize}


La formule de récurrence se réécrit $\mu_1^1(\mathcal{B}) = \mu_0^1(\mathcal{B}) + \mathcal{B}$,
puis, via le binôme de Newton, nous obtenons ce qui suit.

\begin{stepcalc}[style=sar]
	\big( \tabell[m+n][p+n] \big)_{(p,m) \in \NN^2}
\explnext{}
    ( \mu_1^1 )^n(\mathcal{B})
\explnext*{$\ident$ est l'application identité sur $\ell(\NN^2 , \RR)$.}{}
    (\mu_0^1 + \ident)^n(\mathcal{B})
\explnext*{$\mu_0^1$ et $\ident$ commutent.}{}
    \big( \dsum_{k=0}^n \combi[n][k] (\mu_0^1)^k \circ \ident^{n-k} \big)(\mathcal{B})
\explnext{}
    \big( \dsum_{k=0}^n \combi[n][k] \mu_0^k \big)(\mathcal{B})
%\explnext{}
%    \dsum_{k=0}^n \combi[n][k] \mu_0^k(\mathcal{B})
\explnext{}
    \big( \dsum_{k=0}^n \combi[n][k] \tabell[m+k][p] \big)_{(p,m) \in \NN^2}
\end{stepcalc}

Pour conclure,
le choix $p = m = 1$ donne
$\tabell[n+1][n+1] = \dsum_{k=0}^n \combi[n][k] \tabell[k+1][1]$
comme souhaité.


% ----------------------- %


\begin{remark}
	Comme pour la suite de Fibonacci, il est aisé de produire de nouvelles formules de récurrence.
	%
	Partons de $\mu_0^1(\mathcal{B}) = \mu_1^1(\mathcal{B}) -\mathcal{B}$.

    \begin{stepcalc}[style=sar]
    	\big( \tabell[m+n][p] \big)_{(p,m) \in \NN^2}
    \explnext{}
        ( \mu_0^1 )^n(\mathcal{B})
    \explnext{}
        ( \mu_1^1 - \ident )^n(\mathcal{B})
    \explnext{}
        \big( \dsum_{k=0}^n \combi[n][k] (-1)^{n-k} \mu_k^k \big)(\mathcal{B})
    \explnext{}
        \big( \dsum_{k=0}^n \combi[n][k] (-1)^{n-k} \tabell[m+k][p+k] \big)_{(p,m) \in \NN^2}
    \end{stepcalc}
    
    Nous obtenons facilement
    $\tabell[m+n][p] = \sum_{k=0}^n \combi[n][k] (-1)^{n-k} \tabell[m+k][p+k]$.
    %
    Avec $(p,m) = (1,1)$, nous arrivons à
    $\tabell[n+1][1] = \sum_{k=0}^n \combi[n][k] (-1)^{n-k} \tabell[k+1][k+1]$,
    qui correspond à
    $B_n = \sum_{k=0}^n \combi[n][k] (-1)^{n-k} B_{k+1}$,
    soit la formule d'inversion de Pascal pour
    $a_n = B_n$
    et
    $b_n = B_{n+1}$.
    %
    Tandis que $(p,m) = (0,0)$ fournit
    $\tabell[n][0] = \sum_{k=0}^n \combi[n][k] (-1)^{n-k} \tabell[k][k]$,
    soit
    $\tabell[n][0] = \sum_{k=0}^n \combi[n][k] (-1)^{n-k} B_k$
    qui lie le nombre de partitions sans singleton aux nombres de Bell
    (voir la section \ref{tree-bell} page \pageref{tree-bell}).

    
\end{remark}
