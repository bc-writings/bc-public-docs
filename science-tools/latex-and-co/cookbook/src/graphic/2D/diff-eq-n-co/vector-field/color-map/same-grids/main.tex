% !TEX TS-program = lualatex

%%%
% src::
%     url = https://github.com/pfradin/luadraw/discussions/111#discussioncomment-14560468
%%%

\documentclass{standalone}

%%%
% Des couleurs nommées faciles d'emploi via le package ''xcolor''!
%%%
\usepackage[svgnames]{xcolor}

%%%
% La bibliothèque ''luadraw'' allie une facilité d’utilisation à
% un rendu particulièrement soigné.
%%%
\usepackage[3d]{luadraw}

\begin{document}

\begin{luadraw}{name = vector-field-same-grids}
require 'luadraw_palettes'

------
-- Considérons `y' = f(x, y)` où `f(x, y) = x^2 + y^2 - 1` avec
-- la ¨cond initiale `y(0) = 1/2`.
------
local f = function(x, y)
  return x^2 + y^2 - 1
end

local A_0 = Z(0, 1/2)

------
-- Réglages liés au tracé.
------
local xmin, xmax, ymin, ymax = -3, 3, -3, 3

local nb_divs = 20

local pal = getPal["palJet"]

------
-- ¨Def de la zone graphique.
------
local graphview = graph:new{
  window = {xmin - 0.5, xmax + 0.5, ymin - 0.5, ymax + 0.5},
  bg     = "",
  size   = {10, 10}
}

------
-- Construction du champ de ¨vects et de la "¨surf de niveau".
------
local delta_X = (xmax - xmin) / nb_divs
local delta_Y = (ymax - ymin) / nb_divs

local vectors = {}
local values  = {}
local x, y, img, v

local vect_norm = math.min(delta_X, delta_Y) - 0.1

local key

local img_min = math.huge
local img_max = - math.huge

for i = 1, nb_divs do
  x = xmin + delta_X * (i - 0.5)

  for j = 1, nb_divs do
    y = ymin + delta_X * (j - 0.5)

    key = i .. "/" .. j
    img = f(x, y)

    if img < img_min then
      img_min = img
    end

    if img > img_max then
      img_max = img
    end

    values[key] = img

    v = Z(1, img)
    v = v / cpx.abs(v) * vect_norm

    table.insert(vectors, {Z(x, y), Z(x, y) + v})
  end
end


------
-- Construction de la "¨surf de niveau".
------
local color

for i = 1, nb_divs do
  x = xmin + delta_X * (i - 1)

  for j = 1, nb_divs do
    y = ymin + delta_X * (j - 1)

    color = palette(
      pal,
      (values[i .. "/" .. j] - img_min) / (img_max - img_min)
    )

    graphview:Dpolyline(
      {
        Z(x, y),
        Z(x + delta_X, y),
        Z(x + delta_X, y + delta_Y),
        Z(x, y + delta_Y)
      },
      "fill opacity = 0.5, draw = none, fill = " .. color
    )
  end
end

------
-- Ajout d'un cadre gradué.
------
graphview:Dgradbox(
  {
    Z(xmin, ymin), Z(xmax, ymax),
    1, 1
  },
  {
    originloc = 0,
    originnum = {0, 0},
    nbsubdiv  = {3, 3}
  }
)

------
-- Tracé des vecteurs.
------
graphview:Dpolyline(vectors, "-latex, darkgray")

------
-- ¨luadraw va résoudre et tracer la ¨sol de l'¨eq_diff.
------
graphview:Dodesolve(
  f,
  A_0.re, A_0.im,
  {
    t            = {xmin, xmax},
    clip         = {-2.5, 2.25, ymin, ymax},
    nbdots       = 150,
    draw_options = "Navy, line width = 1pt"
  }
)

------
-- Ajout du point initial.
------
graphview:Dlabeldot(
  "{\\boldmath $A_0$}", A_0, {pos = "S", node_options = "Navy"}
)

------
-- Montrons le résultat de notre oeuvre.
------
graphview:Show()
\end{luadraw}

\end{document}
