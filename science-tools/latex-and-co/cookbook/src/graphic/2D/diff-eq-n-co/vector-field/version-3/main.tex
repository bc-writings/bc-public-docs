% !TEX TS-program = lualatex

%%%
% src::
%     url = https://github.com/pfradin/luadraw/discussions/111#discussioncomment-14570983
%%%

\documentclass{standalone}

%%%
% Des couleurs nommées faciles d'emploi via le package ''xcolor''!
%%%
\usepackage[svgnames]{xcolor}

%%%
% La bibliothèque ''luadraw'' allie une facilité d’utilisation à
% un rendu particulièrement soigné.
%%%
\usepackage[3d]{luadraw}

%%%
% La bibliothèque ''shadings'' propre à \tikz nous permet d'avoir
% facilement des dégradés colorés.
%%%
\usetikzlibrary{shadings}

\begin{document}

\begin{luadraw}{name = so-cute-vector-field}
------
-- Considérons `y' = f(x, y)` où `f(x, y) = x^2 + y^2 - 1` avec
-- la ¨cond initiale `y(0) = 1/2`.
------
local f = function(x, y)
  return x^2 + y^2 - 1
end

local A_0 = Z(0, 1/2)

------
-- Réglages liés au tracé.
------
local x1, x2, y1, y2 = -3, 3, -3, 3

local nb_divs = 20

local spectrum = {Purple, Indigo, Blue, Green, Yellow, Orange, Red}

------
-- ¨Def de la zone graphique.
------
local graphview = graph:new{
  window = {x1 - 0.5, x2 + 0.5, y1 - 0.5, y2 + 0.5},
  bg     = "",
  size   = {10, 10}
}

------
-- Construction du champ de ¨vects.
------
local delta_X = (x2 - x1) / nb_divs
local delta_Y = (y2 - y1) / nb_divs

local vect_norm = math.min(delta_X, delta_Y) - 0.1

local vectors = {}
local v

local x, y, img, color

local values = {}
local key

local img_min, img_max = math.huge, -math.huge


for i = 0, nb_divs do
  x = x1 + delta_X * i

  local x1 = x + delta_X / 2

  for j = 0, nb_divs do
    y  = y1 + delta_X * j
    local y1 = y  + delta_Y / 2

    key = i .. "/" .. j
    img = f(x, y)

    if img < img_min then
      img_min = img
    end

    if img > img_max then
      img_max = img
    end

    values[key] = img

    if i < nb_divs and j <nb_divs then
      v = Z(1, f(x1, y1))
      v = v/cpx.abs(v)*vect_norm

      table.insert(vectors, {Z(x1, y1), Z(x1, y1)+v} )
    end
  end
end

local left_colors, right_colors = {}, {}

for j = 0, nb_divs do
  key = "0/" .. j

  color = mixcolor(
    palette(
        spectrum,
        (values[key]-img_min)/(img_max-img_min),
        true
    ),
    0.85, White, 0.15
  ) -- to replace the *fill opacity = 0.5" option

  table.insert(right_colors, color)
end

local eps = 1e-2 -- to widen the squares a little

local col_0, col_1, col_2, col_3, options

for i = 0, nb_divs - 1 do
  x = x1 + delta_X * i

  left_colors, right_colors = right_colors, {}

  for j = 0, nb_divs do
    key = i .. "/" .. j

    color = mixcolor(
      palette(
        spectrum,
        (values[key] - img_min) / (img_max - img_min),
        true
      ),
      0.85, White, 0.15
    )

    table.insert(right_colors, color)
  end

  for j = 0, nb_divs - 1 do
    y = y1 + delta_X * j

    col_0 = left_colors[j + 1]
    col_1 = right_colors[j + 1]
    col_2 = right_colors[j + 2]
    col_3 = left_colors[j + 2]

    options = (
         "upper left = " .. col_3
      .. ", upper right = " .. col_2
      .. ", lower left = " .. col_0
      .. ", lower right = " .. col_1
    )

    graphview:Dpolyline(
      {
        Z(x - eps, y - eps),
        Z(x + delta_X + eps, y - eps),
        Z(x + delta_X + eps, y + delta_Y + eps),
        Z(x - eps, y + delta_Y + eps)
      },
      "draw = none, fill opacity = 0.5, " .. options
    )
  end
end

------
-- Ajout d'un cadre gradué.
------
graphview:Dgradbox(
  {
    Z(x1, y1), Z(x2, y2),
    1, 1
  },
  {
    originloc = 0,
    originnum = {0, 0},
    nbsubdiv  = {3, 3}
  }
)

------
-- Tracé des vecteurs.
------
graphview:Dpolyline(vectors, "-latex, darkgray")

------
-- ¨luadraw va résoudre et tracer la ¨sol de l'¨eq_diff.
------
graphview:Dodesolve(
  f,
  A_0.re, A_0.im,
  {
    t            = {x1, x2},
    clip         = {-2.5, 2.25, y1, y2},
    nbdots       = 150,
    draw_options = "Navy, line width = 1pt"
  }
)

------
-- Ajout du point initial.
------
graphview:Dlabeldot(
  "{\\boldmath $A_0$}", A_0, {pos = "S", node_options = "Navy"}
)

------
-- Et le merveilleux se révèle au monde.
------
graphview:Show()
\end{luadraw}

\end{document}
