Notre objectif est d'obtenir
$F_{m+2n} = \combisum{F_{m+k}}$
où la suite de Fibonacci $F$ vérifie $F_0 = 0$, $F_1 = 1$ et $F_{i} = F_{i-1} + F_{i-2}$.
%
De nouveau, nous allons raisonner en terme d'opérateurs linéaires via les ingrédients naturels suivants.
%
\begin{itemize}
	\item $\ell(\ZZ , \RR)$ désigne l'ensemble des suites réelles indexées sur $\ZZ$.%
	\footnote{
		Si besoin, $\RR$ peut être remplacé par un anneau commutatif de son choix.
	}

	\item $\setalge{A} = \Endo \big( \ell(\ZZ , \RR) \big)$ est l'ensemble des endomorphismes linéaires de $\ell(\ZZ , \RR)$ muni de l'addition $+$ point par point, et de la composition $\circ$ comme produit.

	\item $\sigma_k \in \setalge{A}$ désigne pour $k \in \ZZ$ un opérateur de décalage d'indice qui à la suite $(U_m)_{m\in\ZZ}$ associe la suite $(U_{m+k})_{m\in\ZZ}$.%
	\footnote{
		En considérant $\ell(\NN , \RR)$, nous aurions eu un problème ici.
	}
\end{itemize}


Prolongeons $F$ sur $\ZZsn$ en posant $F_i = 0$, de sorte que $F_{i} = F_{i-1} + F_{i-2}$ reste valable sur $\ZZ$, et se réécrit $\sigma_2(F) = \sigma_1(F) + F$.
%
Dès lors, la conclusion se fait comme suit sans souci.

\begin{stepcalc}[style=sar]
	(F_{m+2n})_{m\in\ZZ}
\explnext{}
    \sigma_2^n(F)
\explnext*{$\ident$ est l'application identité sur $\ell(\ZZ , \RR)$.}{}{}
    (\sigma_1 + \ident)^n(F)
\explnext*{$\sigma_1$ et $\ident$ commutent.}{}
    \big( \dsum_{k=0}^n \combi[n][k] \sigma_1^k \circ \ident^{n-k} \big)(F)
\explnext{}
    \big( \dsum_{k=0}^n \combi[n][k] \sigma_k \big)(F)
%\explnext{}
%    \dsum_{k=0}^n \combi[n][k] \sigma_k(F)
\explnext{}
    \big( \dsum_{k=0}^n \combi[n][k] F_{m+k} \big)_{m\in\ZZ}
\end{stepcalc}


% ----------------------- %


\begin{remark}
    En considérant
    $F = \sigma_2(F) - \sigma_1(F)$,
    nous pouvons conduire les calculs suivants.
    
    \begin{stepcalc}[style=sar]
    	(F_m)_{m\in\ZZ}
    \explnext{}
        (\sigma_2 - \sigma_1)^n(F)
    \explnext*{$\sigma_1$ et $\sigma_2$ commutent.}{}
        \big( \dsum_{k=0}^n \combi[n][k] (-1)^{n-k} \sigma_2^k \circ \sigma_1^{n-k} \big)(F)
%    \end{stepcalc}
%    	
%    \newpage
%    Poursuivons notre calcul.
%    
%    \begin{stepcalc}[style=sar]
%    	(F_m)_{m\in\ZZ}
%    \explnext{}
%        \big( \dsum_{k=0}^n \combi[n][k] (-1)^{n-k} \sigma_{2k} \circ \sigma_{n-k} \big)(F)
%    \explnext{}
%        \big( \dsum_{k=0}^n \combi[n][k] (-1)^{n-k} \sigma_{n + k} \big)(F)
%    \explnext{}
%        \dsum_{k=0}^n \combi[n][k] (-1)^{n-k} \sigma_{n + k}(F)
    \explnext*{$\sigma_2^k \circ \sigma_1^{n-k} = \sigma_{n+k}$}{}
        \big( \dsum_{k=0}^n \combi[n][k] (-1)^{n-k} F_{m+n+k} \big)_{m\in\ZZ}
    \end{stepcalc}
    
    
    Nous obtenons sans effort
    $F_m = \dsum_{k=0}^n \combi[n][k] (-1)^{n-k} F_{m+n+k}$.
    %
    En partant de
    $\sigma_1(F) = \sigma_2(F) - F$,
    nous arrivons aux manipulations ci-dessous.
    
    \begin{stepcalc}[style=sar]
    	(F_{m+n})_{m\in\ZZ}
    \explnext{}
        (\sigma_1)^n(F)
    \explnext{}
        (\sigma_2 - \ident)^n(F)
    \explnext{}
        \big( \dsum_{k=0}^n \combi[n][k] (-1)^{n-k} \sigma_{2k} \big)(F)
    %\explnext{}
    %    \big( \dsum_{k=0}^n \combi[n][k] (-1)^{n+k} F_{m+2k} \big)_{m\in\ZZ}
    \explnext{}
        \big( \dsum_{k=0}^n \combi[n][k] (-1)^{n-k} F_{m+2k} \big)_{m\in\ZZ}
    \end{stepcalc}
    
    
    Le choix $m = 0$ fournit
    $F_n = \combisum{(-1)^{n-k} F_{2k}}$
    qui correspond à une instance de la formule d'inversion de Pascal via
    $a_n = F_n$
    et
    $b_n = F_{2n}$.
\end{remark}


% ----------------------- %


\begin{remark}
	La généralisation à une suite récurrente vérifiant
	$U_{i} = p U_{i-1} + q U_{i-2}$
	ne pose pas de difficulté via
	$\sigma_2(U) = p \sigma_1(U) + q U$
	qui donne, sans effort, $U_{2n} = \combisum{p^k q^{n-k} U_{k}}$.
	%
	Si $p \neq 0$ et $q \neq 0$, alors
    $\sigma_1(U) = p^{-1}(\sigma_2(U) - q U)$
    donne
    $U_n = \combisum{p^{-n} (-q)^{n-k} U_{2k}}$,
    une instance de la formule d'inversion de Pascal via
    $a_n = U_n$
    et
    $b_n = U_{2n}$.
\end{remark}
